
import numpy as np

def fft(A):
    return np.fft.fftshift(np.fft.fftn(np.fft.ifftshift(A)))

def ifft(A):
    return np.fft.fftshift(np.fft.ifftn(np.fft.ifftshift(A)))

def fresnelZone(wavelength,dist):
    return 0.5*np.sqrt(wavelength*dist)

def fresnelSep(wavelength,diffractiveScale):
    return (diffractiveScale*2)**2/wavelength

class gaussianDecomposition(object):
    def __init__(self,params):
        self.x0 = params[:,0]
        self.y0 = params[:,1]
        self.z0 = params[:,2]
        self.a = params[:,3]
        self.bx = params[:,4]
        self.by = params[:,5]
        self.bz = params[:,6]    

    def compute_zeroth(self,x,y,z):
        '''Return the nearest.'''
        zero = 1. 
        i = 0
        while i < np.size(self.x0):
            zero += self.a[i]*np.exp(-(x-self.x0[i])**2/self.bx[i]**2-(y-self.y0[i])**2/self.by[i]**2-(z-self.z0[i])**2/self.bz[i]**2)
            i += 1
        return np.abs(zero)

class NObject(gaussianDecomposition):
    def __init__(self,params):
        super(NObject,self).__init__(params)
#    def __init__(self,data,x,y,z):
#        '''data is cartesian, but compute will be in spherical'''
#        super(NObject,self).__init__(data,x,y,z)
    def compute_n(self,x,y,z):
        #convert r,theta,phi to x,y,z
        #x,y,z = coordsSph2Cart(r,theta,phi)
        return self.compute_zeroth(x,y,z)

def propagate(x,y,z,layers,wavelength,L,M,NObj):
    
    numLayers = len(layers.keys())
    #propagate 1,0 from ground to sky
    #first find x,y offset
    
    #Ground layer
    X = 0.
    Y = 0.
    
    n0sintheta0 = np.sqrt(L**2+M**2)
    Cl = L/np.sqrt(L**2+M**2)
    Cm = M/np.sqrt(L**2+M**2)
    layer = 0
    Ms = []
    Mp = []
    #setup directions to project
    for l,m in zip(L.flatten(),M.flatten()):
        Ms.append(np.eye(2))
        Mp.append(np.eye(2))
    n1 = np.ones_like(L)#vacuum base
    while layer < numLayers:
        X = X + layers[layer]['width']*n0sintheta0/n1 * Cl
        Y = Y + layers[layer]['width']*n0sintheta0/n1 * Cm
        x0 = (x-X)
        y0 = (y-Y)
        n2 = n1
        #for each direction build,Mn s/p
        if layer == numLayers-1:
            n1 = np.ones_like(n1sintheta1)
        else:
            n1 = NObj.compute_n(x0,y0,layers[layer+1]['height'])
        #print n1/n2
        n1sintheta1 = n0sintheta0
        n2sintheta2 = n0sintheta0
        sintheta1 = n1sintheta1/n1
        sintheta2 = n2sintheta2/n2
        costheta2 = np.sqrt(1-sintheta2**2)
        costheta1 = np.sqrt(1-sintheta1**2)
        n2costheta2 = n2*costheta2
        n1costheta1 = n1*costheta1
        n1costheta2 = n1*costheta2
        n2costheta1 = n2*costheta1

        #fresnel equations
        rnn1s = (n1costheta1 - n2costheta2)/(n1costheta1 + n2costheta2)
        tnn1s = 2*n1costheta1/(n1costheta1 + n2costheta2)
        rnn1p = (n2costheta1 - n1costheta2)/(n2costheta1 + n1costheta2)
        tnn1p = 2*n1costheta1/(n2costheta1 + n1costheta2)
        if layer == numLayers-1:
            deltan = np.zeros_like(L)
        else:
            deltan = layers[layer+1]['width']*2*np.pi/wavelength*n1costheta1
        i = 0
        for rnn1si,rnn1pi,tnn1si,tnn1pi,deltani in zip(rnn1s.flatten(),rnn1p.flatten(),tnn1s.flatten(),tnn1p.flatten(),deltan.flatten()):
            Ms[i] = (np.array([[np.exp(-1j*deltani),0],[0,np.exp(1j*deltani)]]).dot(np.array([[1,rnn1si],[rnn1si,1]]))/tnn1si).dot(Ms[i])
            Mp[i] = (np.array([[np.exp(-1j*deltani),0],[0,np.exp(1j*deltani)]]).dot(np.array([[1,rnn1pi],[rnn1pi,1]]))/tnn1pi).dot(Mp[i])
            i += 1
        layer += 1
    ts = []
    tp = []

    i = 0
    for l,m in zip(L.flatten(),M.flatten()):
        ts.append(1./Ms[i][0,0])
        tp.append(1./Mp[i][0,0])
        i += 1
    ts = np.reshape(ts,L.shape)
    tp = np.reshape(tp,L.shape)
    return ts,tp
    
def makeLayers(widths,numLayers):
    layer = 1
    layers = {}
    layers[0] = {'height':0,'width':widths}
    while layer < numLayers:
        layers[layer] = {'width' : widths,
                        'height' : layers[layer-1]['height']+layers[layer-1]['width']}
                        #'n':1+0.1*np.exp(-((X)**2+Y**2+(width*layer-1000-imi*F1/15.)**2)/50.)+0.1*np.exp(-((X)**2+(Y-5*F1/15.)**2+(width*layer-1000)**2)/50.)+0.0001*np.random.uniform(size=X.shape)}#m
        layer += 1
    return layers

def computeVisibilities(xvec,yvec,zvec,lvec,mvec,avec,NObj,wavelength):
    N = len(xvec)
    i = 0
    Us,Up = [],[]
    while i < N:
        #antenna based gains in lvec,mvec direction
        ts,tp = propagate(xvec[i],yvec[i],zvec[i],layers,wavelength,lvec,mvec,NObj)
        #could also apply reception pattern
        Us.append(np.sum(ts*avec*np.exp(1j*2*np.pi*(lvec*xvec[i]+mvec*yvec[i])/wavelength)))
        Up.append(np.sum(tp*avec*np.exp(1j*2*np.pi*(lvec*xvec[i]+mvec*yvec[i])/wavelength)))
        i += 1
    Vs = np.outer(Us,np.conj(Us))
    Vp = np.outer(np.sum(Tp,axis=1),np.conj(np.sum(Tp,axis=1)))
    U = np.zeros_like(Vs)
    V = np.zeros_like(Vs)
    i = 0
    while i < N:
        j = i+1
        while j < N:
            U[i,j] = xvec[i]-xvec[j]
            U[j,i] = -U[j,i] 
            V[i,j] = yvec[i]-yvec[j]
            V[j,i] = -V[j,i]    
            j += 1
        i += 1
    return U,V,Vs,Vp
    #return Vs,Vp
    #print Ts
    points = []
    vis = []
    u,v=[],[]
    bl = []
    i = 0
    while i < N:
        j = 0
        while j < N:
            u.append(xvec[i]-xvec[j])
            v.append(yvec[i]-yvec[j])
            points.append(np.array([xvec[i]-xvec[j],yvec[i]-yvec[j]]))
            vis.append(np.sum(Ts[i])*np.conj(np.sum(Ts[j])))
            
            bl.append([xvec[i]-xvec[j],yvec[i]-yvec[j],zvec[i]-zvec[j]])
            
            j += 1
        i += 1
    uvec = np.linspace(np.min(points),np.max(points),1000)
    U,V = np.meshgrid(uvec,uvec)
    import pylab as plt
    from scipy.interpolate import griddata
    visArray = griddata((u,v),np.real(vis),(U.flatten(),V.flatten()),method='nearest') + 1j*griddata((u,v),np.imag(vis),(U.flatten(),V.flatten()),method='nearest')
    visArray = np.reshape(visArray,U.shape)
    visArray[np.isnan(visArray)] = 0.
    plt.imshow(np.abs(visArray))
    plt.show()
    img = ifft(visArray)
    plt.imshow(np.abs(img))
    plt.show()
    bl = np.array(bl)
    uv = np.sqrt(bl[:,0]**2 + bl[:,1]**2)
    
    plt.scatter(uv.flatten(),np.abs(Vs.flatten()))
    #plt.scatter(bl[:,0],bl[:,1])
    #plt.imshow(np.abs(Vs),origin='lower')
    #plt.colorbar()
    plt.show()
    return Vs,Vp
    
def simVis(params,args):
    shape = args[0]
    xvec,yvec,zvec = args[1],args[2],args[3]#antenna positions
    lvec,mvec,avec = args[4],args[5],args[6]#model
    Vs_true,Vp_true = args[7],args[8]
    NObj = NObject(np.reshape(params,shape))
    Vs,Vp = computeVisibilities(xvec,yvec,zvec,lvec,mvec,avec,NObj)
    chi = np.mean(np.angle(Vs_true - Vs) + np.angle(Vp_true - Vp))
    print chi
    return chi
    
def noAtmosphere():
    x0 = [0]#*np.cos(c0.spherical.lon.rad+0.1)*np.sin(np.pi/2-c0.spherical.lat.rad)]
    y0 = [0.]#*np.sin(c0.spherical.lon.rad)*np.sin(np.pi/2-c0.spherical.lat.rad)]
    z0 = [0]#*np.cos(np.pi/2-c0.spherical.lat.rad)]
    a = [0.]
    bx=[1]
    by=[1]
    bz=[1]
    params = np.array([x0,y0,x0,a,bx,by,bz]).transpose()
    NObj = NObject(params)
    return NObj

if __name__=='__main__':
    wavelength = 1.
    width = fresnelSep(wavelength,5000)
    numLayers = 1000000.
    print("Number of layers:",numLayers)
    F1 = fresnelZone(wavelength,width)
    print ("Fresnel zone:",F1)
    layers = makeLayers(width,numLayers)
    #atmosphere
    NObj = noAtmosphere()    
    #sources
    lvec = [0.]
    mvec = [0.]
    avec = [1.]
    #antennas
    numAntennas = 15
    maxUV = 1./(25./3600.*np.pi/180.)
    xvec = np.sort(np.random.uniform(size=10))*maxUV*wavelength
    yvec = np.sort(np.random.uniform(size=10))*maxUV*wavelength
    zvec = np.random.uniform(size=10)*0
    U,V,Vs,Vp = computeVisibilities(xvec,yvec,zvec,lvec,mvec,avec,NObj,wavelength)
    import pylab as plt
    plt.imshow(np.angle(Vs),extent=[])
    #lvec = np.linspace(-.1,.1,100)
    #mvec = np.linspace(-.1,.1,100)
    #mvec = np.fft.fftshift(np.fft.fftfreq(len(yvec),d=dy/wavelength))
    #L,M = np.meshgrid(lvec,mvec)
    #framespol = []
    #frameppol = []
    #li = np.argmin((lvec-0)**2)
    #mi = np.argmin((mvec-0)**2)
    #vis = []
    #frame = 0
    #build ref
    
    #x,y,z = 0,0.,0
    #ts1ref,tp1ref = propagate(x,y,z,layers,wavelength,L,M,NObj)
    xvec = np.random.uniform(size=10)
    yvec = np.random.uniform(size=10)
    zvec = np.random.uniform(size=10)*0
    lvec = np.array([0,0.05,0.05,0.1,0.2])
    mvec = np.array([0.05,0,0.05,0.2,0.])
    avec = np.array([0.1,0.2,0.3,0.4,0.5])
    Vs,Vp = computeVisibilities(xvec,yvec,zvec,lvec,mvec,avec,NObj)
    plt.imshow(np.angle(Vs))
    plt.colorbar()
    plt.show()
    from scipy.optimize import minimize
    params0 = np.copy(params)
    params0[0,3] = 0#a=0
    args = [np.shape(params0),xvec,yvec,zvec ,lvec,mvec,avec,Vs_true,Vp_true]
    res = minimize(simVis,params0,args,method='Powell')
    print res.x,params
    
    while frame < 20:
        x0 = [0.,0.]#*np.cos(c0.spherical.lon.rad+0.1)*np.sin(np.pi/2-c0.spherical.lat.rad)]
        y0 = [0.+F1*frame,-F1*frame*5]#*np.sin(c0.spherical.lon.rad)*np.sin(np.pi/2-c0.spherical.lat.rad)]
        z0 = [width,width]#*np.cos(np.pi/2-c0.spherical.lat.rad)]
        a = [0.1,0.1]
        bx=[width/2,width/5]
        by=[width/5,width/2]
        bz=[width/2,width/2.]
        
        params = np.array([x0,y0,x0,a,bx,by,bz]).transpose()
        NObj = NObject(params)
        Vs,Vp = computeVisibilities(xvec,yvec,zvec,lvec,mvec,avec,NObj)
        x,y,z = 0,0.,0
        #ts1,tp1 = propagate(x,y,z,layers,wavelength,L,M,NObj)
        x,y,z = 0,F1/5,0
        #ts2,tp2 = propagate(x,y,z,layers,wavelength,L,M,NObj)
        #vis.append(ts1[li,mi]*ts2[li,mi])
        #framespol.append(ts1)#/ts1ref)
        #frameppol.append(tp1)#/tp1ref)
        frame += 1
    import pylab as plt

    f = plt.figure()
    plt.plot(np.angle(vis))
    plt.xlabel('time')
    plt.ylabel('phase')
    f.savefig('figs/spl_vis.png')
    plt.close()

    i = 0
    for im in framespol:
        f = plt.figure()
        plt.imshow(np.angle(im),origin='lower',extent=[lvec[0],lvec[-1],mvec[0],mvec[-1]])
        plt.colorbar(label='phase (rad)')
        plt.xlabel('l')
        plt.ylabel('m')
        f.savefig('figs/spl_phase_{0:04d}.png'.format(i))
        plt.close()
        i += 1
    i = 0
    for im in frameppol:
        f = plt.figure()
        plt.imshow(np.angle(im),origin='lower',extent=[lvec[0],lvec[-1],mvec[0],mvec[-1]])
        plt.colorbar(label='phase (rad)')
        plt.xlabel('l')
        plt.ylabel('m')
        f.savefig('figs/ppl_phase_{0:04d}.png'.format(i))
        plt.close()
        i += 1
    
        
    
   
        

vis

vis


