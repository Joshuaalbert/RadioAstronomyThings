
#!/bin/env python

"""
This solves for the terms common scalar phase, tec, and complex gain using MH algorithm.
author: Joshua Albert
albert@strw.leidenuniv.nl
"""

import numpy as np
import pylab as plt

TECU = 10e16
def clock_tec_solve(obs_phase, freqs, times, plot = False):
    '''Solves for the terms phase(CS,TEC,delay) = CS + e^2/(4pi ep0 me c) * TEC/nu + 2pi*nu*delay
    
    Assumes phase is in units of radians, freqs in is units of Hz, 
    and times is in units of seconds with arbitrary offset
    
    obs_phase is shape (num_freqs, num_times)'''
     
    binning = 50
    convergence = binning**2 * len(times)*3
    def calc_phase(cs,tec,delay, freqs):
        phase = np.multiply.outer(np.ones(len(freqs)),cs) + 8.44797256e-7*TECU * np.multiply.outer(1./freqs,tec) + 2.*np.pi*np.multiply.outer(freqs,delay)
        return phase
    
    def neglogL(obs_phase,phase,CdCt):
        L2 = obs_phase - phase
        L2 *= L2
        L2 /= CdCt
        return np.sum(L2)/2.
    
    def sample_prior(last, stats):
        cs = last[0,:] + np.random.uniform(low = -0.01, high=0.01,size=len(times))
        tec = last[1,:] + np.random.uniform(low=-0.1,high=0.1,size=len(times))
        delay = last[2,:] + np.random.uniform(low=-1e-10,high=1e-10,size=len(times))
        return cs,tec,delay
    # come up with initial guess
    cs0  = np.zeros(len(times),dtype=np.double)
    delay0 = np.zeros(len(times),dtype=np.double)
    tec0 = np.zeros(len(times),dtype=np.double)
#     # d/dnu (phase*nu) = cs + 4pi*nu*delay
    x0 = (freqs*obs_phase.T).T
    x1 = ((x0[1:,:] - x0[:-1,:]).T/(freqs[1:] - freqs[:-1])).T
#     # d^2/dnu^2 (phase*nu) = 4pi*delay
    x2 = ((x1[1:,:] - x1[:-1,:]).T/(freqs[1:-1] - freqs[:-2])).T
    delay0 = np.mean(x2,axis=0)/4./np.pi
    x3 = 2*np.pi*np.multiply.outer(freqs,delay0)
    cs0 = np.mean(x1 - 2.*x3[1:,:],axis=0)
#     #broadcast and take mean
#     tec0 = np.mean(((obs_phase - x3 - np.multiply.outer(freqs,cs0)).T/(8.44797256e-7*np.multiply.outer(1./freqs,np.ones(len(times))*TECU))).T, axis=0)
    print("Initial CS: {}".format(cs0))
    print("Initial TEC: {}".format(tec0))
    print("Initial delay: {}".format(delay0))
#     if plot:
#         plt.plot(times,cs0,label="CS0")
#         plt.plot(times,tec0,label="TEC0")
#         plt.plot(times,delay0,label="delay0")
#         plt.legend(frameon=False)
#         plt.show()
    Ct = (0.1*np.abs(obs_phase))**2
    Cd = (10*np.pi/180.)**2
    CdCt = Cd+Ct
    Si = neglogL(obs_phase,calc_phase(cs0,tec0,delay0,freqs),CdCt)
    print("Initial Si: {}".format(Si))
    max_iter = 1e7
    posterior = np.zeros([convergence,3,len(times)],dtype=np.double)
    multiplicity = np.zeros(convergence,dtype=np.double)
    posterior[0,0,:] = cs0
    posterior[0,1,:] = tec0
    posterior[0,2,:] = delay0
    minS = Si
    minSol = cs0,tec0, delay0
    accepted = 1
    iter = 1
    while accepted < convergence:
        #sample
        cs_j,tec_j,delay_j = sample_prior(posterior[accepted-1,:])
        Sj = neglogL(obs_phase,calc_phase(cs_j,tec_j,delay_j,freqs),CdCt)
        Lj = np.exp(-Sj)
        #print(Sj)
        if Sj < Si or np.log(np.random.uniform()) < Si - Sj:
            Si = Sj
            posterior[accepted,0,:] = cs_j
            posterior[accepted,1,:] = tec_j
            posterior[accepted,2,:] = delay_j
            multiplicity[accepted] += 1
            print("{}, Accepted with {}".format(accepted/float(convergence),Si))
            accepted += 1
        else:
            multiplicity[accepted-1] += 1
        if Sj < minS:
            minSol = cs_j,tec_j, delay_j
            minS = Sj
        iter += 1
    if accepted == convergence:
        print("Converged in {} steps with an acceptance rate of {}".format(iter,float(accepted)/iter))
    else:
        posterior = posterior[:iter,:,:]
        multiplicity = multiplicity[:iter]
    mean = np.sum(posterior.T*multiplicity,axis=2)/np.sum(multiplicity)
    std = np.sqrt(np.sum(posterior.T**2*multiplicity,axis=2)/np.sum(multiplicity) - mean**2)
    print ("(Gaussian) sol is {} +- {}".format(mean,std))
    if plot:
        plt.plot(times,mean[0,:],label="CS")
        plt.plot(times,mean[1,:],label="TEC")
        plt.plot(times,mean[2,:],label="delay")
        plt.legend(frameon=False)
        plt.show()
            
def test_clock_tec_solve():
    times = np.arange(1)
    freqs = np.linspace(110e6,170e6,100)
    cs = times*0.01
    tec = np.random.uniform(size=len(times))*0.01
    delay = np.ones(len(times)) * 1e-9# 10ns
    phase = np.multiply.outer(np.ones(len(freqs)),cs) + 8.44797256e-7*TECU*np.multiply.outer(1./freqs,tec) + 2.*np.pi*np.multiply.outer(freqs,delay)
    phase += 10.*np.pi/180.*np.random.normal(size=[len(freqs),len(times)])
    plt.imshow(phase,origin='lower',extent=(times[0],times[-1],freqs[0],freqs[-1]),aspect='auto')
    plt.colorbar()
    plt.xlabel('times (s)')
    plt.ylabel('freqs (Hz)')
    plt.show()
    clock_tec_solve(phase, freqs, times, plot=True)
if __name__ == '__main__':
    test_clock_tec_solve()



