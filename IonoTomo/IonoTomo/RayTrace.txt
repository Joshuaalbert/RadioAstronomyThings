
from Geometry import *
from itertools import combinations

def makeOctTree(eastWidth,northWidth,pointingHeight,alt,az,minSep):
    '''Define an OctTree with pointing and given dimensions
    minSep - minimum seperation between sources in radians'''
    minCellSize = np.tan(minSep)*pointingHeight
    center = np.array([0,0,pointingHeight/2.])
    masterOctTree = OctTree(center,eastWidth,northWidth,pointingHeight)
    while masterOctTree.minCellSize()[0] > minCellSize:
        masterOctTree.subDivide()
    
    

def makePlanes(height,width,du,dw):
    planes = []
    h = 0
    while h < height:
        planes.append(Plane(np.array([0,0,h]),normal=np.array([0,0,1])))
        h += dw

    h = 0
    while h < width:
        planes.append(Plane(np.array([0,h-width/2.,0]),normal=np.array([0,1,0])))
        h += du

    h = 0
    while h < width:
        planes.append(Plane(np.array([h-width/2.,0,0]),normal=np.array([1,0,0])))
        h += du
    return planes

def buildOctTree(center,dx,dy,dz):
    voxels = []
    for center in centers:
        voxel.append(Voxel(center=center,dx=dx,dy=dy,dz=dz))
    

def point2index(point,du,dw):
    nu = np.floor(point[0]/du)
    nv = np.floor(point[1]/du)
    nw = np.floor(point[2]/dw)
    return nu,nv,nw    
    
def getClosestApproach(segs):
    '''Get the closest approach between all segs'''
    closest = {}
    for seg1 in segs:
        sep = np.inf 
        for seg2 in segs:
            if np.alltrue(seg1.origin == seg2.origin):
                continue
            res,seg = intersectRayRay(seg1,seg2)
            if res:
                sep = 0
                closest[seg1] = LineSegment(seg,seg)#seg is a point
                break
            if seg.sep < sep:
                sep = seg.sep
                clostest[seg1] = seg
    return closest

            
            
                
def tracer(sources,recievers):
    segs = []
    for s in sources:
        for r in recievers:
            seg = LineSegment(r,s)
            segs.append(seg)
    #get closest approach
    print getClosestApproach(segs)
    #build OctTree
    mean = (np.mean(sources,axis=0) + np.mean(recievers,axis=0))/2
    lims = np.max([np.max(sources,axis=0),np.max(recievers,axis=0)],axis=0)-np.min([np.min(sources,axis=0),np.min(recievers,axis=0)],axis=0)
    print mean,lims
    octTree =  OctTree(center=mean,dx=lims[0],dy = lims[1], dz = lims[2])
    octTree.subDivide().subDivide().subDivide()
    plotProj(segs,octTree.getAllBoundingPlanes()[0],np.array([0,1,0]))
    #build model
    for seg in segs:
        rayLengths = []
        octTree.intersectRay(seg)
            
def plotProj(lineSegs,planes,projDir):
    import pylab as plt
    projPlane = Plane([0,0,0],normal=projDir)
    xdir,ydir,zdir = gramSchmidt(projDir)
    R = np.array([xdir,ydir,zdir])
    f = plt.figure()
    ax = plt.subplot(111)
    count = 0
    for seg in lineSegs:
        count += 1
        x1 = R.dot(seg.origin)
        x2 = R.dot(seg.eval(seg.sep))
        ax.plot([x1[0],x2[0]],[x1[1],x2[1]],label='seg-{0}'.format(count))
    ax.set_xlabel('Dir {0}'.format(xdir))
    ax.set_ylabel('Dir {0}'.format(ydir))
    xmin,xmax = ax.get_xlim()
    ymin,ymax = ax.get_ylim()
    for p in planes:
        res,ray  = intersectPlanePlane(p,projPlane)
        if res:
            tmax = np.sqrt((xmax-xmin)**2 + (ymax - ymin)**2)
            ray = Ray(R.dot(ray.origin),R.dot(ray.dir))
            ax.plot([ray.eval(-tmax)[0],ray.eval(tmax)[0]],[ray.eval(-tmax)[1],ray.eval(tmax)[1]],c='black')
    ax.set_xlim(xmin,xmax)
    ax.set_ylim(ymin,ymax)
    plt.legend(frameon=False)
    plt.show()
        

if __name__=='__main__':
    height = 100.
    width = 15.
    dw = height/10.
    du = width/10.
    s = [np.array([5,0,0]),np.array([2,1,0]),np.array([0,1,0])]
    r = [np.array([0,1,height]),np.array([1,6,height]),np.array([2,-1,height])]

    tracer(s,r)





